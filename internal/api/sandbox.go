package api

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/opensandbox/opensandbox/internal/auth"
	"github.com/opensandbox/opensandbox/pkg/types"
	pb "github.com/opensandbox/opensandbox/proto/worker"
)

func (s *Server) createSandbox(c echo.Context) error {
	var cfg types.SandboxConfig
	if err := c.Bind(&cfg); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "invalid request body: " + err.Error(),
		})
	}

	ctx := c.Request().Context()

	// Check org quota if PG is available
	orgID, hasOrg := auth.GetOrgID(c)
	if hasOrg && s.store != nil {
		org, err := s.store.GetOrg(ctx, orgID)
		if err == nil {
			count, err := s.store.CountActiveSandboxes(ctx, orgID)
			if err == nil && count >= org.MaxConcurrentSandboxes {
				return c.JSON(http.StatusTooManyRequests, map[string]string{
					"error": "concurrent sandbox limit reached",
				})
			}
		}
	}

	// Server mode with worker registry: dispatch to remote worker via gRPC
	if s.workerRegistry != nil {
		return s.createSandboxRemote(c, ctx, cfg, orgID, hasOrg)
	}

	// Combined/worker mode: create locally
	if s.manager == nil {
		return c.JSON(http.StatusServiceUnavailable, errSandboxNotAvailable)
	}

	sb, err := s.manager.Create(ctx, cfg)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": err.Error(),
		})
	}

	// Register with sandbox router for rolling timeout tracking
	if s.router != nil {
		timeout := cfg.Timeout
		if timeout <= 0 {
			timeout = 300
		}
		s.router.Register(sb.ID, time.Duration(timeout)*time.Second)
	}

	// Initialize per-sandbox SQLite if available
	if s.sandboxDBs != nil {
		sdb, err := s.sandboxDBs.Get(sb.ID)
		if err == nil {
			_ = sdb.LogEvent("created", map[string]string{
				"sandbox_id": sb.ID,
				"template":   cfg.Template,
			})
		}
	}

	// Issue sandbox-scoped JWT for combined mode
	if s.jwtIssuer != nil {
		timeout := cfg.Timeout
		if timeout <= 0 {
			timeout = 300
		}
		token, err := s.jwtIssuer.IssueSandboxToken(orgID, sb.ID, s.workerID, time.Duration(timeout)*time.Second)
		if err == nil {
			sb.Token = token
		}
	}

	// Assign subdomain
	if s.sandboxDomain != "" {
		sb.Domain = fmt.Sprintf("%s.%s", sb.ID, s.sandboxDomain)
	}

	// Write session record to PG if available
	if s.store != nil && hasOrg {
		cfgJSON, _ := json.Marshal(cfg)
		metadataJSON, _ := json.Marshal(cfg.Metadata)
		region := s.region
		if region == "" {
			region = "local"
		}
		workerID := s.workerID
		if workerID == "" {
			workerID = "w-local-1"
		}
		template := cfg.Template
		if template == "" {
			template = "base"
		}
		_, _ = s.store.CreateSandboxSession(ctx, sb.ID, orgID, nil, template, region, workerID, cfgJSON, metadataJSON)
	}

	return c.JSON(http.StatusCreated, sb)
}

// createSandboxRemote dispatches sandbox creation to a remote worker via gRPC.
func (s *Server) createSandboxRemote(c echo.Context, ctx context.Context, cfg types.SandboxConfig, orgID [16]byte, hasOrg bool) error {
	// Select region (explicit header, or default to server's region)
	region := c.Request().Header.Get("Fly-Region")
	if region == "" {
		region = s.region
	}
	if region == "" {
		region = "iad"
	}

	worker, grpcClient, err := s.workerRegistry.GetLeastLoadedWorker(region)
	if err != nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "no workers available: " + err.Error(),
		})
	}

	// Dispatch via persistent gRPC connection
	grpcCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	grpcResp, err := grpcClient.CreateSandbox(grpcCtx, &pb.CreateSandboxRequest{
		Template:       cfg.Template,
		Timeout:        int32(cfg.Timeout),
		Envs:           cfg.Envs,
		MemoryMb:       int32(cfg.MemoryMB),
		CpuCount:       int32(cfg.CpuCount),
		NetworkEnabled: cfg.NetworkEnabled,
	})
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "worker create failed: " + err.Error(),
		})
	}

	// Issue sandbox-scoped JWT
	timeout := cfg.Timeout
	if timeout <= 0 {
		timeout = 300
	}
	var token string
	if s.jwtIssuer != nil {
		t, err := s.jwtIssuer.IssueSandboxToken(orgID, grpcResp.SandboxId, worker.ID, time.Duration(timeout)*time.Second)
		if err != nil {
			log.Printf("sandbox: failed to issue JWT: %v", err)
		} else {
			token = t
		}
	}

	// Record session in PG
	if s.store != nil && hasOrg {
		template := cfg.Template
		if template == "" {
			template = "base"
		}
		cfgJSON, _ := json.Marshal(cfg)
		metadataJSON, _ := json.Marshal(cfg.Metadata)
		_, _ = s.store.CreateSandboxSession(ctx, grpcResp.SandboxId, orgID, nil, template, region, worker.ID, cfgJSON, metadataJSON)
	}

	resp := map[string]interface{}{
		"sandboxID":  grpcResp.SandboxId,
		"connectURL": worker.HTTPAddr,
		"token":      token,
		"status":     grpcResp.Status,
		"region":     region,
		"workerID":   worker.ID,
	}
	if s.sandboxDomain != "" {
		resp["domain"] = fmt.Sprintf("%s.%s", grpcResp.SandboxId, s.sandboxDomain)
	}

	return c.JSON(http.StatusCreated, resp)
}

func (s *Server) getSandbox(c echo.Context) error {
	id := c.Param("id")

	// Server mode with worker registry: look up from PG and issue fresh token
	if s.workerRegistry != nil {
		return s.getSandboxRemote(c, id)
	}

	// Combined/worker mode: look up locally
	if s.manager == nil {
		return c.JSON(http.StatusServiceUnavailable, errSandboxNotAvailable)
	}

	sb, err := s.manager.Get(c.Request().Context(), id)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{
			"error": err.Error(),
		})
	}

	if s.jwtIssuer != nil {
		orgID, hasOrg := auth.GetOrgID(c)
		if hasOrg {
			token, err := s.jwtIssuer.IssueSandboxToken(orgID, id, s.workerID, 24*time.Hour)
			if err == nil {
				sb.Token = token
			}
		}
	}

	if s.sandboxDomain != "" {
		sb.Domain = fmt.Sprintf("%s.%s", id, s.sandboxDomain)
	}

	return c.JSON(http.StatusOK, sb)
}

// getSandboxRemote looks up a sandbox via the PG session record and returns
// the worker's connectURL + a fresh JWT.
func (s *Server) getSandboxRemote(c echo.Context, sandboxID string) error {
	if s.store == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "database not configured",
		})
	}

	session, err := s.store.GetSandboxSession(c.Request().Context(), sandboxID)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{
			"error": "sandbox not found",
		})
	}

	// Hibernated sandboxes have no worker
	if session.Status == "hibernated" {
		resp := map[string]interface{}{
			"sandboxID": sandboxID,
			"status":    "hibernated",
			"region":    session.Region,
			"template":  session.Template,
			"startedAt": session.StartedAt,
		}
		if s.sandboxDomain != "" {
			resp["domain"] = fmt.Sprintf("%s.%s", sandboxID, s.sandboxDomain)
		}
		return c.JSON(http.StatusOK, resp)
	}

	// Look up worker address
	worker := s.workerRegistry.GetWorker(session.WorkerID)
	connectURL := ""
	if worker != nil {
		connectURL = worker.HTTPAddr
	}

	// Issue a fresh token
	orgID, _ := auth.GetOrgID(c)
	var token string
	if s.jwtIssuer != nil {
		t, err := s.jwtIssuer.IssueSandboxToken(orgID, sandboxID, session.WorkerID, 24*time.Hour)
		if err == nil {
			token = t
		}
	}

	resp := map[string]interface{}{
		"sandboxID":  sandboxID,
		"connectURL": connectURL,
		"token":      token,
		"status":     session.Status,
		"region":     session.Region,
		"workerID":   session.WorkerID,
		"startedAt":  session.StartedAt,
		"template":   session.Template,
	}
	if s.sandboxDomain != "" {
		resp["domain"] = fmt.Sprintf("%s.%s", sandboxID, s.sandboxDomain)
	}

	return c.JSON(http.StatusOK, resp)
}

func (s *Server) killSandbox(c echo.Context) error {
	id := c.Param("id")

	// Server mode with worker registry: dispatch destroy via gRPC
	if s.workerRegistry != nil {
		return s.killSandboxRemote(c, id)
	}

	// Combined/worker mode: kill locally
	if s.manager == nil {
		return c.JSON(http.StatusServiceUnavailable, errSandboxNotAvailable)
	}

	if err := s.manager.Kill(c.Request().Context(), id); err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": err.Error(),
		})
	}

	// Unregister from sandbox router
	if s.router != nil {
		s.router.Unregister(id)
	}

	if s.store != nil {
		_ = s.store.UpdateSandboxSessionStatus(c.Request().Context(), id, "stopped", nil)
	}

	if s.sandboxDBs != nil {
		_ = s.sandboxDBs.Remove(id)
	}

	return c.NoContent(http.StatusNoContent)
}

// killSandboxRemote dispatches sandbox destruction to the appropriate worker via gRPC.
func (s *Server) killSandboxRemote(c echo.Context, sandboxID string) error {
	if s.store == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "database not configured",
		})
	}

	session, err := s.store.GetSandboxSession(c.Request().Context(), sandboxID)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{
			"error": "sandbox not found",
		})
	}

	// Attempt gRPC destroy (best-effort)
	client, err := s.workerRegistry.GetWorkerClient(session.WorkerID)
	if err != nil {
		// Worker is unreachable â€” mark as error in PG
		log.Printf("sandbox: worker %s unreachable for destroy: %v", session.WorkerID, err)
		errMsg := "worker unreachable"
		_ = s.store.UpdateSandboxSessionStatus(c.Request().Context(), sandboxID, "error", &errMsg)
		return c.NoContent(http.StatusNoContent)
	}

	grpcCtx, cancel := context.WithTimeout(c.Request().Context(), 10*time.Second)
	defer cancel()

	if _, err := client.DestroySandbox(grpcCtx, &pb.DestroySandboxRequest{SandboxId: sandboxID}); err != nil {
		log.Printf("sandbox: gRPC destroy failed for %s: %v", sandboxID, err)
	}

	_ = s.store.UpdateSandboxSessionStatus(c.Request().Context(), sandboxID, "stopped", nil)

	return c.NoContent(http.StatusNoContent)
}

func (s *Server) listSandboxes(c echo.Context) error {
	// Server mode with worker registry: query PG for org's running sandboxes
	if s.workerRegistry != nil {
		return s.listSandboxesRemote(c)
	}

	// Combined/worker mode: list locally
	if s.manager == nil {
		return c.JSON(http.StatusServiceUnavailable, errSandboxNotAvailable)
	}

	sandboxes, err := s.manager.List(c.Request().Context())
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": err.Error(),
		})
	}

	return c.JSON(http.StatusOK, sandboxes)
}

// listSandboxesRemote queries PG for the org's running sandboxes and returns
// connectURL + fresh JWT for each.
func (s *Server) listSandboxesRemote(c echo.Context) error {
	if s.store == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "database not configured",
		})
	}

	orgID, ok := auth.GetOrgID(c)
	if !ok {
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"error": "org context required",
		})
	}

	sessions, err := s.store.ListSandboxSessions(c.Request().Context(), orgID, "running", 100, 0)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": err.Error(),
		})
	}

	result := make([]map[string]interface{}, 0, len(sessions))
	for _, sess := range sessions {
		entry := map[string]interface{}{
			"sandboxID": sess.SandboxID,
			"status":    sess.Status,
			"region":    sess.Region,
			"workerID":  sess.WorkerID,
			"template":  sess.Template,
			"startedAt": sess.StartedAt,
		}

		// Attach connectURL from registry
		worker := s.workerRegistry.GetWorker(sess.WorkerID)
		if worker != nil {
			entry["connectURL"] = worker.HTTPAddr
		}

		// Issue fresh JWT
		if s.jwtIssuer != nil {
			token, err := s.jwtIssuer.IssueSandboxToken(orgID, sess.SandboxID, sess.WorkerID, 24*time.Hour)
			if err == nil {
				entry["token"] = token
			}
		}

		result = append(result, entry)
	}

	return c.JSON(http.StatusOK, result)
}

func (s *Server) setTimeout(c echo.Context) error {
	// In server mode, timeout must be set directly on the worker via connectURL
	if s.workerRegistry != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "timeout must be set directly on the worker via connectURL",
		})
	}

	if s.router == nil {
		return c.JSON(http.StatusServiceUnavailable, errSandboxNotAvailable)
	}

	id := c.Param("id")

	var req types.TimeoutRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "invalid request body: " + err.Error(),
		})
	}

	if req.Timeout <= 0 {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "timeout must be positive",
		})
	}

	s.router.SetTimeout(id, time.Duration(req.Timeout)*time.Second)

	return c.NoContent(http.StatusNoContent)
}

func (s *Server) hibernateSandbox(c echo.Context) error {
	id := c.Param("id")
	ctx := c.Request().Context()

	// Server mode: dispatch to worker via gRPC
	if s.workerRegistry != nil {
		return s.hibernateSandboxRemote(c, id)
	}

	// Combined mode: hibernate locally
	if s.manager == nil || s.checkpointStore == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "hibernation not available",
		})
	}

	result, err := s.manager.Hibernate(ctx, id, s.checkpointStore)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": err.Error(),
		})
	}

	// Mark hibernated in sandbox router
	if s.router != nil {
		timeout := 600 // default for explicit hibernate
		s.router.MarkHibernated(id, time.Duration(timeout)*time.Second)
	}

	// Record checkpoint in PG
	orgID, hasOrg := auth.GetOrgID(c)
	if s.store != nil && hasOrg {
		session, _ := s.store.GetSandboxSession(ctx, id)
		cfg := json.RawMessage("{}")
		if session != nil {
			cfg = session.Config
		}
		template := "base"
		region := s.region
		if session != nil {
			template = session.Template
			region = session.Region
		}
		_, _ = s.store.CreateCheckpoint(ctx, id, orgID, result.CheckpointKey, result.SizeBytes, region, template, cfg)
		_ = s.store.UpdateSandboxSessionStatus(ctx, id, "hibernated", nil)
	}

	if s.sandboxDBs != nil {
		_ = s.sandboxDBs.Remove(id)
	}

	return c.JSON(http.StatusOK, map[string]interface{}{
		"sandboxID":     id,
		"status":        "hibernated",
		"checkpointKey": result.CheckpointKey,
		"sizeBytes":     result.SizeBytes,
	})
}

func (s *Server) hibernateSandboxRemote(c echo.Context, sandboxID string) error {
	if s.store == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "database not configured",
		})
	}

	session, err := s.store.GetSandboxSession(c.Request().Context(), sandboxID)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "sandbox not found"})
	}
	if session.Status != "running" {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "sandbox is not running"})
	}

	client, err := s.workerRegistry.GetWorkerClient(session.WorkerID)
	if err != nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{"error": "worker unreachable"})
	}

	grpcCtx, cancel := context.WithTimeout(c.Request().Context(), 60*time.Second)
	defer cancel()

	grpcResp, err := client.HibernateSandbox(grpcCtx, &pb.HibernateSandboxRequest{
		SandboxId: sandboxID,
	})
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "hibernate failed: " + err.Error(),
		})
	}

	// Record checkpoint in PG
	orgID, _ := auth.GetOrgID(c)
	_, _ = s.store.CreateCheckpoint(c.Request().Context(), sandboxID, orgID,
		grpcResp.CheckpointKey, grpcResp.SizeBytes,
		session.Region, session.Template, session.Config)
	_ = s.store.UpdateSandboxSessionStatus(c.Request().Context(), sandboxID, "hibernated", nil)

	resp := map[string]interface{}{
		"sandboxID":     sandboxID,
		"status":        "hibernated",
		"checkpointKey": grpcResp.CheckpointKey,
		"sizeBytes":     grpcResp.SizeBytes,
	}
	if s.sandboxDomain != "" {
		resp["domain"] = fmt.Sprintf("%s.%s", sandboxID, s.sandboxDomain)
	}

	return c.JSON(http.StatusOK, resp)
}

func (s *Server) wakeSandbox(c echo.Context) error {
	id := c.Param("id")
	ctx := c.Request().Context()

	var req types.WakeRequest
	_ = c.Bind(&req)

	// Server mode: pick any worker, dispatch via gRPC
	if s.workerRegistry != nil {
		return s.wakeSandboxRemote(c, id, req)
	}

	// Combined mode: wake locally
	if s.manager == nil || s.checkpointStore == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "hibernation not available",
		})
	}

	// Get checkpoint key from PG
	if s.store == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "database not configured",
		})
	}

	checkpoint, err := s.store.GetActiveCheckpoint(ctx, id)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "no active checkpoint found"})
	}

	sb, err := s.manager.Wake(ctx, id, checkpoint.CheckpointKey, s.checkpointStore, req.Timeout)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": err.Error(),
		})
	}

	// Register with sandbox router after explicit wake
	if s.router != nil {
		timeout := req.Timeout
		if timeout <= 0 {
			timeout = 300
		}
		s.router.Register(id, time.Duration(timeout)*time.Second)
	}

	_ = s.store.MarkCheckpointRestored(ctx, id)
	_ = s.store.UpdateSandboxSessionForWake(ctx, id, s.workerID)

	// Issue fresh JWT
	orgID, _ := auth.GetOrgID(c)
	if s.jwtIssuer != nil {
		timeout := req.Timeout
		if timeout <= 0 {
			timeout = 300
		}
		token, err := s.jwtIssuer.IssueSandboxToken(orgID, id, s.workerID, time.Duration(timeout)*time.Second)
		if err == nil {
			sb.Token = token
		}
	}

	sb.ConnectURL = s.httpAddr
	if s.sandboxDomain != "" {
		sb.Domain = fmt.Sprintf("%s.%s", id, s.sandboxDomain)
	}

	return c.JSON(http.StatusOK, sb)
}

func (s *Server) wakeSandboxRemote(c echo.Context, sandboxID string, req types.WakeRequest) error {
	if s.store == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "database not configured",
		})
	}

	checkpoint, err := s.store.GetActiveCheckpoint(c.Request().Context(), sandboxID)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "no active checkpoint found"})
	}

	session, err := s.store.GetSandboxSession(c.Request().Context(), sandboxID)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "sandbox session not found"})
	}
	if session.Status != "hibernated" {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "sandbox is not hibernated"})
	}

	// Pick ANY worker in the same region
	region := checkpoint.Region
	worker, grpcClient, err := s.workerRegistry.GetLeastLoadedWorker(region)
	if err != nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "no workers available in region " + region,
		})
	}

	grpcCtx, cancel := context.WithTimeout(c.Request().Context(), 60*time.Second)
	defer cancel()

	grpcResp, err := grpcClient.WakeSandbox(grpcCtx, &pb.WakeSandboxRequest{
		SandboxId:     sandboxID,
		CheckpointKey: checkpoint.CheckpointKey,
		Timeout:       int32(req.Timeout),
	})
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": "wake failed: " + err.Error(),
		})
	}

	// Mark checkpoint as restored, update session
	_ = s.store.MarkCheckpointRestored(c.Request().Context(), sandboxID)
	_ = s.store.UpdateSandboxSessionForWake(c.Request().Context(), sandboxID, worker.ID)

	// Issue fresh JWT
	orgID, _ := auth.GetOrgID(c)
	timeout := req.Timeout
	if timeout <= 0 {
		timeout = 300
	}
	var token string
	if s.jwtIssuer != nil {
		t, err := s.jwtIssuer.IssueSandboxToken(orgID, sandboxID, worker.ID, time.Duration(timeout)*time.Second)
		if err == nil {
			token = t
		}
	}

	resp := map[string]interface{}{
		"sandboxID":  sandboxID,
		"connectURL": worker.HTTPAddr,
		"token":      token,
		"status":     grpcResp.Status,
		"region":     region,
		"workerID":   worker.ID,
	}
	if s.sandboxDomain != "" {
		resp["domain"] = fmt.Sprintf("%s.%s", sandboxID, s.sandboxDomain)
	}

	return c.JSON(http.StatusOK, resp)
}

// listSessions returns session history from PostgreSQL.
func (s *Server) listSessions(c echo.Context) error {
	if s.store == nil {
		return c.JSON(http.StatusServiceUnavailable, map[string]string{
			"error": "session history requires database configuration",
		})
	}

	orgID, ok := auth.GetOrgID(c)
	if !ok {
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"error": "org context required",
		})
	}

	status := c.QueryParam("status")
	sessions, err := s.store.ListSandboxSessions(c.Request().Context(), orgID, status, 100, 0)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"error": err.Error(),
		})
	}

	return c.JSON(http.StatusOK, sessions)
}
